package exploitdb

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

// Exploit represents a single exploit entry from go-exploitdb
type Exploit struct {
	ID          string `json:"id"`
	Name        string `json:"name"` // Often the title or description
	Type        string `json:"type"`
	URL         string `json:"url"`
	Description string `json:"description"`
	Date        string `json:"date"`
	Author      string `json:"author"`
}

// Client handles interactions with the go-exploitdb binary and server
type Client struct {
	BinaryPath string
	ServerURL  string
	serverCmd  *exec.Cmd
}

// NewClient creates a new client, looking for the binary in PATH
func NewClient() (*Client, error) {
	path, err := exec.LookPath("go-exploitdb")
	if err != nil {
		return nil, fmt.Errorf("go-exploitdb binary not found: %w", err)
	}
	return &Client{
		BinaryPath: path,
		ServerURL:  "http://127.0.0.1:1326",
	}, nil
}

// StartServer starts the go-exploitdb server in the background
func (c *Client) StartServer() error {
	// Check if already running? (Simple check: try to connect)
	if c.IsServerRunning() {
		return nil
	}

	cmd := exec.Command(c.BinaryPath, "server", "--port", "1326")
	// cmd.Stdout = os.Stdout // Optional logging
	// cmd.Stderr = os.Stderr
	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start exploitdb server: %w", err)
	}
	c.serverCmd = cmd

	// Give it a moment to start
	time.Sleep(2 * time.Second)
	return nil
}

// IsServerRunning checks if the server is responsive
func (c *Client) IsServerRunning() bool {
	resp, err := http.Get(c.ServerURL + "/health") // Assuming /health or just root
	if err != nil {
		// Try root if health doesn't exist, or just assume down
		_, err := http.Get(c.ServerURL)
		return err == nil
	}
	resp.Body.Close()
	return true
}

// StopServer stops the background server
func (c *Client) StopServer() {
	if c.serverCmd != nil && c.serverCmd.Process != nil {
		c.serverCmd.Process.Kill()
	}
}

// Search searches for exploits related to a CVE ID using the HTTP API
func (c *Client) Search(cveID string) ([]Exploit, error) {
	// GET /cves/{cveID}
	resp, err := http.Get(fmt.Sprintf("%s/cves/%s", c.ServerURL, cveID))
	if err != nil {
		return nil, fmt.Errorf("failed to request exploits: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// 404 might mean no results, but API usually returns empty list?
		// If 404, return empty
		if resp.StatusCode == http.StatusNotFound {
			return []Exploit{}, nil
		}
		return nil, fmt.Errorf("server returned status: %s", resp.Status)
	}

	var exploits []Exploit
	// The API returns a list of exploits directly
	if err := json.NewDecoder(resp.Body).Decode(&exploits); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return exploits, nil
}

// Fetch updates the exploit database
func (c *Client) Fetch() error {
	// go-exploitdb fetch exploitdb
	cmd := exec.Command(c.BinaryPath, "fetch", "exploitdb")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// CheckUpdates checks if the database needs updating (e.g., older than 24h)
func (c *Client) CheckUpdates() (bool, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return false, err
	}
	timestampFile := filepath.Join(home, ".go-exploitdb-last-update")

	info, err := os.Stat(timestampFile)
	if os.IsNotExist(err) {
		return true, nil // Never updated
	}
	if err != nil {
		return false, err
	}

	// If older than 24 hours
	if time.Since(info.ModTime()) > 24*time.Hour {
		return true, nil
	}

	return false, nil
}

// MarkUpdated updates the timestamp file
func (c *Client) MarkUpdated() error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	timestampFile := filepath.Join(home, ".go-exploitdb-last-update")
	f, err := os.Create(timestampFile)
	if err != nil {
		return err
	}
	return f.Close()
}
